""" Use UTF-8 encoding
set encoding=utf-8

""" Use spacebar as leader
let mapleader = "\<space>"

""" Backups and swap
set swapfile
if !isdirectory($HOME . "/.vim/swap")
    silent call mkdir($HOME . "/.vim/swap", 'p')
endif
set directory=~/.vim/swap//,.

set backup
set writebackup
if !isdirectory($HOME . "/.vim/backup")
    silent call mkdir($HOME . "/.vim/backup", "p")
endif
set backupdir=~/.vim/swap//,.

set undofile
if !isdirectory($HOME . "/.vim/undo")
    silent call mkdir($HOME . "/.vim/undo", "p")
endif
set undodir=~/.vim/undo//,.

""" Jump to last cursor position after opening a file
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif

""" Stop netrw from keeping history
let g:netrw_dirhistmax = 0

""" Use paths relative to current file
set autochdir

""" Command history
set history=1000

""" Don't redraw when running macros
set lazyredraw

""" Faster timeouts
set timeout timeoutlen=1000 ttimeoutlen=100

""" Backspace through startpoint, eol, etc.
set backspace=indent,eol,start

""" Search and replace
set incsearch
set hlsearch
set ignorecase
set smartcase
set gdefault
noremap <silent> <Leader>/ :noh<CR>

""" Tabs
set expandtab
set shiftwidth=4
set softtabstop=4

""" Visual autocomplete commands
set wildmenu

""" Colors
set background=dark
colorscheme gruvbox
set cursorline
set colorcolumn=81

""" Display status bar with line and column numbers
set laststatus=2
set ruler

""" Display relative line numbers
set number
set relativenumber

""" Show folds on left side column, start with all folds open
set foldcolumn=1
set foldmethod=syntax
autocmd BufWinEnter * silent! :%foldopen!

""" Syntax highlighting and indentation
syntax on
filetype plugin indent on
""" Small changes to C and C++ indentation
" (Do not indent switch cases, do not indent C++ scope declarations,
" do not indent C++ namespaces)
set cinoptions=:0,l1,g0,N-s

""" Draw on trailing pace
set list listchars=tab:\ \ ,trail:Â·

""" Do not wrap long line
set nowrap

""" Scroll before reaching end of screen
set scrolloff=4

""" Splits open below and to the right
set splitbelow
set splitright

""" Allow me to move away from modified buffers
set hidden

""" Display current command as it gets typed
set showcmd

""" Enable mouse if possible
if has('mouse')
    set mouse=a
endif

""" Allow moving beyond end of lines in visual block
set virtualedit=block

""" Shortcuts for closing, quitting, saving
noremap <leader>d :bd<CR>
noremap <leader>q :q<CR>
noremap <leader>x :x<CR>

""" Shortcuts for moving between buffers and splits
noremap <leader>n :bn<CR>
noremap <leader>N :bp<CR>
noremap <leader>p :bp<CR>
noremap <leader>b :b#<CR>
noremap <leader>w <C-w>

""" Shortcuts for toggles
noremap <leader>tl :set wrap!<CR>
noremap <leader>tn :set number!<CR>
noremap <leader>tr :set relativenumber!<CR>
noremap <leader>tw :set list!<CR>

""" Shortcuts for editing related stuff
nmap <leader>c gcc
vmap <leader>c gc
noremap <leader>+ <c-a>
noremap <leader>- <c-x>
noremap <silent> <leader>W :%s/\s\+$//e<CR>

""" YouCompleteMe setup
let g:ycm_always_populate_location_list=1
noremap <leader>E :YcmDiags<CR>
noremap <leader>ed :YcmShowDetailedDiagnostic<CR>
noremap <silent> <leader>en :try<bar>lnext<bar>catch /^Vim\%((\a\+)\)\=:E\%(553\):/<bar>lfirst<bar>catch /^Vim\%((\a\+)\)\=:E\%(42\):/<bar>echo "No errors"<bar>endtry<cr>
noremap <silent> <leader>eN :try<bar>lprevious<bar>catch /^Vim\%((\a\+)\)\=:E\%(553\):/<bar>llast<bar>catch /^Vim\%((\a\+)\)\=:E\%(42\):/<bar>echo "No errors"<bar>endtry<cr>
noremap <silent> <leader>ep :try<bar>lprevious<bar>catch /^Vim\%((\a\+)\)\=:E\%(553\):/<bar>llast<bar>catch /^Vim\%((\a\+)\)\=:E\%(42\):/<bar>echo "No errors"<bar>endtry<cr>
map gd :YcmCompleter GoTo<CR>

""" altr setup (jump to alternative file, header file, etc)
map <leader>a <Plug>(altr-forward)
map <leader>A <Plug>(altr-back)
